<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cisco Service Layer API: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="projectlogo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cisco Service Layer API
   </div>
   <div id="projectbrief">Routing, MPLS, and BFD services</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Quick&#160;Start</span></a></li>
      <li><a href="/"><span>Home</span></a></li>
      <li><a href="modules.html"><span>Services</span></a></li>
      <li><a href="annotated.html"><span>Messages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Cisco Service Layer API Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Doxygen filter for Google Protocol Buffers .proto files.</h1>
<h1>This script converts .proto files into C++ style ones</h1>
<h1>and prints the output to standard output.</h1>
<p># </p>
<h1>version 0.6-beta</h1>
<p># </p>
<h1>How to enable this filter in Doxygen:</h1>
<h1>1. Generate Doxygen configuration file with command 'doxygen -g '</h1>
<h1>e.g. doxygen -g doxyfile</h1>
<h1>2. In the Doxygen configuration file, find JAVADOC_AUTOBRIEF and set it enabled</h1>
<h1>JAVADOC_AUTOBRIEF = YES</h1>
<h1>3. In the Doxygen configuration file, find FILE_PATTERNS and add *.proto</h1>
<h1>FILE_PATTERNS = *.proto</h1>
<h1>4. In the Doxygen configuration file, find EXTENSION_MAPPING and add proto=C</h1>
<h1>EXTENSION_MAPPING = proto=C</h1>
<h1>5. In the Doxygen configuration file, find INPUT_FILTER and add this script</h1>
<h1>INPUT_FILTER = "python proto2cpp.py"</h1>
<h1>6. Run Doxygen with the modified configuration</h1>
<h1>doxygen doxyfile</h1>
<p># # </p>
<h1>Copyright (C) 2012-2015 Timo Marjoniemi</h1>
<h1>All rights reserved.</h1>
<p># </p>
<h1>This library is free software; you can redistribute it and/or</h1>
<h1>modify it under the terms of the GNU Lesser General Public</h1>
<h1>License as published by the Free Software Foundation; either</h1>
<h1>version 2.1 of the License, or (at your option) any later version.</h1>
<p># </p>
<h1>This library is distributed in the hope that it will be useful,</h1>
<h1>but WITHOUT ANY WARRANTY; without even the implied warranty of</h1>
<h1>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</h1>
<h1>Lesser General Public License for more details.</h1>
<p># </p>
<h1>You should have received a copy of the GNU Lesser General Public</h1>
<h1>License along with this library; if not, write to the Free Software</h1>
<h1>Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</h1>
<p># </p>
<h2></h2>
<p>import os import sys import re import fnmatch import inspect</p>
<h1>Class for converting Google Protocol Buffers .proto files into C++ style output to enable Doxygen usage.</h1>
<h2></h2>
<h1>The C++ style output is printed into standard output.<br/>
</h1>
<h1>There are three different logging levels for the class:</h1>
<h1>#logNone: do not log anything</h1>
<h1>#logErrors: log errors only</h1>
<h1>#logAll: log everything</h1>
<h1>Logging level is determined by <code>#logLevel</code>.<br/>
</h1>
<h1>Error logs are written to file determined by <code>#errorLogFile</code>.<br/>
</h1>
<h1>Debug logs are written to file determined by <code>#logFile</code>.</h1>
<p>#</p>
<p>class proto2cpp: </p>
<pre class="fragment"># Logging level: do not log anything.
logNone = 0
# Logging level: log errors only.
logErrors = 1
# Logging level: log everything.
logAll = 2

# Conmessageor
#
def __init__(self):
    # Debug log file name.
    self.logFile = "proto2cpp.log"
    # Error log file name.
    self.errorLogFile = "proto2cpp.error.log"
    # Logging level.
    self.logLevel = self.logNone

# Handles a file.
##
# If @p fileName has .proto suffix, it is processed through parseFile().
# Otherwise it is printed to stdout as is except for file \c proto2cpp.py without
# path since it's the script given to python for processing.
##
# @param fileName Name of the file to be handled.
#
def handleFile(self, fileName):
    if fnmatch.fnmatch(filename, '*.proto'):
        self.log('\nXXXXXXXXXX\nXX ' + filename + '\nXXXXXXXXXX\n\n')
        # Open the file. Use try to detect whether or not we have an actual
        # file.
        try:
            with open(filename, 'r') as inputFile:
                self.parseFile(inputFile)
            pass
        except IOError as e:
            self.logError(
                'the file ' + filename + ' could not be opened for reading')

    elif not fnmatch.fnmatch(filename, os.path.basename(inspect.getfile(inspect.currentframe()))):
        self.log('\nXXXXXXXXXX\nXX ' + filename + '\nXXXXXXXXXX\n\n')
        try:
            with open(filename, 'r') as theFile:
                output = ''
                for theLine in theFile:
                    output += theLine
                print(output)
                self.log(output)
            pass
        except IOError as e:
            self.logError(
                'the file ' + filename + ' could not be opened for reading')
    else:
        self.log(
            '\nXXXXXXXXXX\nXX ' + filename + ' --skipped--\nXXXXXXXXXX\n\n')

# Parser function.
##
# The function takes a .proto file object as input
# parameter and modifies the contents into C++ style.
# The modified data is printed into standard output.
##
# @param inputFile Input file object
#
def parseFile(self, inputFile):
    # Go through the input file line by line.
    isEnum = False
    # This variable is here as a workaround for not getting extra line breaks (each line
    # ends with a line separator and print() method will add another one).
    # We will be adding lines into this var and then print the var out at
    # the end.
    theOutput = ''
    for line in inputFile:
        # Search for comment ("//") and add one more slash character ("/") to the comment
        # block to make Doxygen detect it.
        matchComment = re.search("//", line)
        # Search for semicolon and if one is found before comment, add a third slash character
        # ("/") and a smaller than ("&lt;") chracter to the comment to make Doxygen detect it.
        matchSemicolon = re.search(";", line)
        if matchSemicolon is not None and (matchComment is not None and matchSemicolon.start() &lt; matchComment.start()):
            line = line[
                :matchComment.start()] + "///&lt;" + line[matchComment.end():]
        elif matchSemicolon is not None and (matchComment is not None and matchSemicolon.start() &gt; matchComment.start()):
            line = line.replace("//", "")
        elif matchComment is not None:
            line = line[
                :matchComment.start()] + "///" + line[matchComment.end():]
        # Search for "enum" and if one is found before comment,
        # start changing all semicolons (";") to commas (",").
        matchEnum = re.search("enum", line)
        if matchEnum is not None and (matchComment is None or matchEnum.start() &lt; matchComment.start()):
            isEnum = True
        # Search again for semicolon if we have detected an enum, and
        # replace semicolon with comma.
        if isEnum is True and re.search(";", line) is not None:
            matchSemicolon = re.search(";", line)
            line = line[
                :matchSemicolon.start()] + "," + line[matchSemicolon.end():]
        # Search for a closing brace.
        matchClosingBrace = re.search("}", line)
        if isEnum is True and matchClosingBrace is not None:
            line = line[
                :matchClosingBrace.start()] + "};" + line[matchClosingBrace.end():]
            isEnum = False
        elif isEnum is False and re.search("}", line) is not None:
            # Message (to be struct) ends =&gt; add semicolon so that it'll
            # be a proper C(++) message and Doxygen will handle it
            # correctly.
            line = line[
                :matchClosingBrace.start()] + "};" + line[matchClosingBrace.end():]
        # Search for 'import' and replace it with '#include' unless
        # 'import' is behind a comment.
        matchMsg = re.search("message", line)
        if matchMsg is not None and (matchComment is None or matchMsg.start() &lt; matchComment.start()):
            line = "struct" + \
                line[:matchMsg.start()] + line[matchMsg.end():]
        matchSrv = re.search("^service", line)
        if matchSrv is not None and (matchComment is None or matchSrv.start() &lt; matchComment.start()):
            line = "namespace" + \
                line[:matchSrv.start()] + line[matchSrv.end():]
        matchImp = re.search("import", line)
        if matchImp is not None and (matchComment is None or matchImp.start() &lt; matchComment.start()):
            line = "#include" + \
                line[:matchImp.start()] + line[matchImp.end():]
        else:
            theOutput += line
        # Search for 'stuct' and replace it with 'message' unless 'message'
        # is behind a comment.

    # Now that we've got all lines in the string let's split the lines and print out
    # one by one.
    # This is a workaround to get rid of extra empty line at the end which
    # print() method adds.
    lines = theOutput.splitlines()
    for line in lines:
        if len(line) &gt; 0:
            print(line)
            # Our logger does not add extra line breaks so explicitly
            # adding one to make the log more readable.
            self.log(line + '\n')
        else:
            self.log('\n   --- skipped empty line')

# Writes @p string to log file.
##
# logLevel must be #logAll or otherwise the logging is skipped.
##
# @param string String to be written to log file.
#
def log(self, string):
    if self.logLevel &gt;= self.logAll:
        with open(self.logFile, 'a') as theFile:
            theFile.write(string)

# Writes @p string to error log file.
##
# logLevel must be #logError or #logAll or otherwise the logging is skipped.
##
# @param string String to be written to error log file.
#
def logError(self, string):
    if self.logLevel &gt;= self.logError:
        with open(self.errorLogFile, 'a') as theFile:
            theFile.write(string)
</pre><p>converter = proto2cpp() </p>
<h1>Doxygen will give us the file names</h1>
<p>for filename in sys.argv: converter.handleFile(filename)</p>
<h1>end of file</h1>
<h1>Python Quick Tutorial</h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#server">Server Setup</a></li>
<li><a href="#quick">Running the tutorial</a></li>
<li><a href="#gen">Generate gRPC Code</a></li>
<li><a href="#init">Initialize the client server connection</a></li>
<li><a href="#vrf">Register the VRF</a></li>
<li><a href="#route">Add a Batch of Routes</a></li>
</ul>
<h4><a class="anchor" id="server"></a>Server Setup</h4>
<p>On the server side, we need to configure GRPC and enable the service layer through the following CLI configuration: </p>
<pre class="fragment">! Configure GRPC
configure
grpc port 57344
grpc address-family ipv4
commit
end

! Configure Service layer
configure
grpc service-layer
commit
end
</pre><p>We also need to configure a server IP address. To configure an IP address on the managment interface, one can use dhcp as follows: </p>
<pre class="fragment">! Configure the Mgmt Interface
configure
interface MgmtEth 0/RP0/CPU0/0
ipv4 address dhcp
no shut
commit
end
</pre><p>To check the IP address assigned: </p>
<pre class="fragment">show ip interface brief
</pre><p>On the client side, the very first thing we need to do is set the server IP address and gRPC port. You can check your port number by running the following CLI command on the IOS-XR server box (should be the same as the one configured): </p>
<pre class="fragment"># show run grpc
</pre><p>Set the server address and port number as environment variables with the following example command (this is assuming you are in bash shell): </p>
<pre class="fragment">$ export SERVER_IP=192.168.122.192
$ export SERVER_PORT=57344
</pre><p>The above assumes that the IP address of the node is 192.168.122.192.</p>
<p>This completes all the setup needed to start writing some code! Hop into your python interpreter and try out some of the commands to get familiar with the API.</p>
<h2><a class="anchor" id="quick"></a>Running the tutorial</h2>
<p>The following basic tutorial will walk you through getting started with the Service Layer API, in particular on how to add a route. This may require some initial python and GRPC setup, which will be explained below. For now, if you already have passed this setup step, run the example: </p>
<pre class="fragment">cd grpc/python/src
python tutorial/quickstart.py
</pre><p>The following sections explain the details of the above example tutorial.</p>
<h4><a class="anchor" id="gen"></a>Generate gRPC Code (optional in this example)</h4>
<p>If you are not familiar with gRPC, we recommend you refer to gRPC's documentation before beginning with our tutorial: <a href="http://www.grpc.io/docs/">gRPC Docs</a></p>
<p>You should have received all of the protobuf files required to run the Cisco Service Laye API. In order to generate the gRPC client side code stubs in python, run the following command (you may have to adjust the path to the proto files and the output according to your requirements):</p>
<p><b>For convenience, these files are also committed in this repo under grpc/python/src/genpy/ (so you can skip this step).</b> </p>
<pre class="fragment">$ protoc -I ../../protos --python_out=. --grpc_out=./genpy/ --plugin=protoc-gen-grpc=`which grpc_python_plugin` ../../protos/*.proto
</pre><p>This generates the code stubs that we will now utilize to create a client. The files are recognizable from the "_pb2" that is appended to the name of the proto files they were generated from (example: sl_route_ipv4_pb2.py).</p>
<h4><a class="anchor" id="init"></a>Initialize the client server connection</h4>
<p>In order to follow this quick tutorial, it is best to open the files in <code>grpc/python/src/tutorial/</code> </p>
<pre class="fragment">quickstart.py  : The full tutorial example
client_init.py : Used to setup the client-server connection
vrf.py         : Used to setup the Route vertical
</pre><p>As shown in quickstart.py, the first thing to do is to setup the GRPC channel: </p>
<pre class="fragment">server_ip, server_port = util.get_server_ip_port()
channel = implementations.insecure_channel(server_ip, server_port)
</pre><p>Once connected, we need to handshake the API version number with the server. The same RPC call also sets up an asynchronous stream of notifications from the server. The first notification would be the response to our version number message i.e. <a class="el" href="group__SLGlobal.html#structSLInitMsg" title="Initialization message sent to the server. ">SLInitMsg</a>, as a <a class="el" href="group__SLGlobal.html#structSLGlobalNotif" title="Globals query message. ">SLGlobalNotif</a> event with type SL_GLOBAL_EVENT_TYPE_VERSION. This can be done by calling: </p>
<pre class="fragment">SLGlobalInitNotif(init_msg, Timeout)
</pre><p>The above function takes the client major, minor and sub version numbers and sends them to the Service Layer service to get a handshake on the API version number. More on this below.</p>
<p>The following code snippets are copied from file client_init.py </p>
<pre class="fragment">def client_init(stub, event):
    #
    # Create SLInitMsg to handshake the version number with the server.
    # The Server will allow/deny access based on the version number.
    # The same RPC is used to setup a notification channel for global
    # events coming from the server.
    #
    # # Set the client version number based on the current proto files' version
    init_msg = sl_global_pb2.SLInitMsg()
    init_msg.MajorVer = sl_version_pb2.SL_MAJOR_VERSION
    init_msg.MinorVer = sl_version_pb2.SL_MINOR_VERSION
    init_msg.SubVer = sl_version_pb2.SL_SUB_VERSION

    # Set a very large timeout, as we will "for ever" loop listening on
    # notifications from the server
    Timeout = 365*24*60*60 # Seconds

    # This for loop will never end unless the server closes the session
    for response in stub.SLGlobalInitNotif(init_msg, Timeout):
        if response.EventType == sl_global_pb2.SL_GLOBAL_EVENT_TYPE_VERSION:
            if (sl_common_types_pb2.SLErrorStatus.SL_SUCCESS ==
                    response.ErrStatus.Status):
</pre><p>The above python definition also handles other events such as errors and heartbeats. Notice that the client_init definition above takes a GRPC stub as an argument. This is typically created through: </p>
<pre class="fragment"># Create the gRPC stub.
stub = sl_global_pb2.beta_create_SLGlobal_stub(channel)
</pre><p>Since the above client_init function would never return, it is best to spawn it as a thread, and run it in the background. In python, we do so by calling a threading event: </p>
<pre class="fragment">#
# Spawn a thread for global events
#
def global_init(channel):
    # Create the gRPC stub.
    stub = sl_global_pb2.beta_create_SLGlobal_stub(channel)

    # Create a thread sync event. This will be used to order thread execution
    event = threading.Event()

    # The main reason we spawn a thread here, is that we dedicate a GRPC
    # channel to listen on Global asynchronous events/notifications.
    # This thread will be handling these event notifications.
    t = threading.Thread(target = global_thread, args=(stub, event))
    t.start()
</pre><h4><a class="anchor" id="vrf"></a>Register the VRF</h4>
<p>In general, before we can use a vertical function like the route APIs, we have to register on that vertical. The route API allows the user to register based on a per VRF basis. So, before any additions or modification of routes can be made we need to register with the proper VRF, which requires sending a VRF registration message and then an EOF message to clean up any stale routes that may be there from an older configuration (this will become handy on restart or recovery scenarios).</p>
<p>The following snippets are copied from file vrf.py</p>
<p>Next up, create the stub instance using the channel. This stub will have the exact same methods that are available on the server. To do this, we need to import the stub code generated from our ProtoBuf files. Depending on what calls you want to make, different stubs will be used. We are going to be making changes to our IPv4 routes, so we use the SLRoutev4Oper_stub. </p>
<pre class="fragment">from genpy import sl_route_ipv4_pb2
stub = sl_route_ipv4_pb2.beta_create_SLRoutev4Oper_stub(channel)
</pre><p>Time to fill in some variables!</p>
<p>Create the <code><a class="el" href="group__SLRouteCommon.html#structSLVrfRegMsg" title="VRF Registration messages. ">SLVrfRegMsg</a></code> object. Generating a <code><a class="el" href="group__SLRouteCommon.html#structSLVrfRegMsg" title="VRF Registration messages. ">SLVrfRegMsg</a></code> object allows us to use dot notation to access and set it's variables. </p>
<pre class="fragment">from genpy import sl_route_common_pb2
vrfMsg = sl_route_common_pb2.SLVrfRegMsg()
</pre><p>The VRF registration message contains a set of VRF registration objects.</p>
<p>Create an <code><a class="el" href="group__SLRouteCommon.html#structSLVrfReg" title="VRF Registration message. ">SLVrfReg</a></code> object. </p>
<pre class="fragment">vrfObj = sl_route_common_pb2.SLVrfReg()
</pre><p>Set the VRF registration object attributes:</p>
<p>VRF name. The default VRF in IOS-XR is called "default": </p>
<pre class="fragment">vrfObj.VrfName = 'default'
</pre><p>Administrative distance. The admin distance is used by RIB to make best path decisions. </p>
<pre class="fragment">vrfObj.AdminDistance = 2
</pre><p>VRF purge interval. This is useful on restart scenarios. </p>
<pre class="fragment">vrfObj.VrfPurgeIntervalSeconds = 500
</pre><p>Add the registration message to the list. In the case of a bulk object, we can append other VRF objects to the list. </p>
<pre class="fragment">vrfList.append(vrfObj)
</pre><p>Now that the list is completed, assign <code>vrf_list</code> to the <code><a class="el" href="group__SLRouteCommon.html#structSLVrfRegMsg" title="VRF Registration messages. ">SLVrfRegMsg</a></code>. </p>
<pre class="fragment">vrfMsg.VrfRegMsgs.extend(vrfList)
</pre><p>Make the RPC call.</p>
<p>We are ready to make our call to the API. We'll send the <code><a class="el" href="group__SLRouteCommon.html#structSLVrfRegMsg" title="VRF Registration messages. ">SLVrfRegMsg</a> vrfMsg</code> and a timeout interval (in seconds) for the gRPC server. </p>
<pre class="fragment">Timeout = 10 # Seconds
response = stub.SLRoutev4VrfRegOp(vrfMsg, Timeout)
</pre><p>Note that the vrfMsg has an Oper field that determines the operation type: </p>
<pre class="fragment">SL_REGOP_REGISTER  : used for registrations
SL_REGOP_EOF       : used for EOF signaling. Useful for restart scenarios
SL_REGOP_UNREGISTER: used to unregister, which would clean all previous roues added in that VRF.
</pre><p>Finally, we can print our response from the server. Notice that, since we can add a batch of VRF registrations, we want to print a result code for each individual response. To do this, we check if the response is an error, and if it is we print the name of the vrf that caused the error as well as the hexadecimal error code. </p>
<pre class="fragment">if (response.StatusSummary.Status ==
        sl_common_types_pb2.SLErrorStatus.SL_SUCCESS):
    print "VRF %s Success!" %(
        sl_common_types_pb2.SLRegOp.keys()[oper])
else:
    print "Error code for VRF %s is 0x%x! Response:" % (
        sl_common_types_pb2.SLRegOp.keys()[oper],
        response.StatusSummary.Status
    )
    print response
    # If we have partial failures within the batch, let's print them
    if (response.StatusSummary.Status == 
        sl_common_types_pb2.SLErrorStatus.SL_SOME_ERR):
        for result in response.Results:
            print "Error code for %s is 0x%x" %(result.VrfName,
                result.ErrStatus.Status
            )
</pre><h4><a class="anchor" id="route"></a>Add a Batch of Routes</h4>
<p>Now that we have registered the VRF, we can start adding routes. We will show adding a batch of 10 routes to the RIB.</p>
<p>Create an empty list of routes. </p>
<pre class="fragment">routeList = []
</pre><p>Create a <code><a class="el" href="group__SLRouteIPv4Oper.html#structSLRoutev4Msg" title="List of routes for bulk download. ">SLRoutev4Msg</a></code> message. </p>
<pre class="fragment">rtMsg = sl_route_ipv4_pb2.SLRoutev4Msg()
</pre><p>Fill in the route attributes.</p>
<p>VRF Name </p>
<pre class="fragment">rtMsg.VrfName = 'default'
</pre><p>Add a loop that will add 10 incrementing routes to the RIB table. </p>
<pre class="fragment">for i in range(10):
</pre><p>Create a <code><a class="el" href="group__SLRouteIPv4Oper.html#structSLRoutev4" title="IPv4 route. ">SLRoutev4</a></code> object. </p>
<pre class="fragment">    route = sl_route_ipv4_pb2.SLRoutev4()
</pre><p>IP address import ipaddress route.Prefix = ( int(ipaddress.ip_address('20.0.'+ str(i) + '.0')) )</p>
<p>Prefix Length </p>
<pre class="fragment">    route.PrefixLen = 24
</pre><p>Administrative distance (this can override the VRF registration admin distance) </p>
<pre class="fragment">    route.RouteCommon.AdminDistance = 2
</pre><p>Set the route's paths.</p>
<p>A route may have one or many paths. Create an empty list of paths as a placeholder for these paths. </p>
<pre class="fragment">    paths = []
</pre><p>Create an <code><a class="el" href="group__SLRouteCommon.html#structSLRoutePath" title="Route Path attributes. ">SLRoutePath</a></code> object. </p>
<pre class="fragment">    path = sl_route_common_pb2.SLRoutePath()
</pre><p>Fill in the path attributes. Note: if you are deleting a route, paths are not required to be added, so it is better not to fill in this part for a delete.</p>
<p>Path next hop address </p>
<pre class="fragment">    path.NexthopAddress.V4Address = (
        int(ipaddress.ip_address('10.10.10.1'))
    )
</pre><p>Next hop interface name </p>
<pre class="fragment">    path.NexthopInterface.Name = 'GigabitEthernet0/0/0/0'
</pre><p>Add the path to the list </p>
<pre class="fragment">    paths.append(path)
</pre><p>Let's create another path as equal cost multi-path (ECMP) </p>
<pre class="fragment">    path = sl_route_common_pb2.SLRoutePath()
    path.NexthopAddress.V4Address = (
        int(ipaddress.ip_address('10.10.10.2'))
    )
    path.NexthopInterface.Name = 'GigabitEthernet0/0/0/0'
    paths.append(path)
</pre><p>Add the paths to the route object. In the example quickstart.py tutorial, we add a line checking that the operation is not a delete operation, as we would not need to add paths for a delete. </p>
<pre class="fragment">    if oper != sl_common_types_pb2.SL_OBJOP_DELETE:
        route.PathList.extend(paths)
</pre><p>Add the route to <code>route_list</code> (bulk routes) </p>
<pre class="fragment">    routeList.append(route)
</pre><p>Assign the <code>routeList</code> to the <code>rtMsg</code>. </p>
<pre class="fragment">rtMsg.Routes.extend(routeList)
</pre><p>Make the RPC call. </p>
<pre class="fragment">Timeout = 10 # Seconds
rtMsg.Oper = oper # Desired ADD, UPDATE, DELETE operation
response = stub.SLRoutev4Op(rtMsg, Timeout)
</pre><p>Again, in the quickstart.py tutorial we have examples of other route calls beyond just adding bulk routes. </p>
<pre class="fragment"># RPC route operations
#    for add: sl_common_types_pb2.SL_OBJOP_ADD
#    for update: sl_common_types_pb2.SL_OBJOP_UPDATE
#    for delete: sl_common_types_pb2.SL_OBJOP_DELETE
route_operation(channel, sl_common_types_pb2.SL_OBJOP_ADD)
</pre><p>These calls show examples of bulk additions, updates, and deletes</p>
<p>Check the server's response. Here again we can check each individual route that was added for an error message. </p>
<pre class="fragment">if (sl_common_types_pb2.SLErrorStatus.SL_SUCCESS == 
        response.StatusSummary.Status):
    print "Route %s Success!" %(
        sl_common_types_pb2.SLObjectOp.keys()[oper])
else:
    print "Error code for route %s is 0x%x" % (
        sl_common_types_pb2.SLObjectOp.keys()[oper],
        response.StatusSummary.Status
    )
    # If we have partial failures within the batch, let's print them
    if (response.StatusSummary.Status == 
        sl_common_types_pb2.SLErrorStatus.SL_SOME_ERR):
        for result in response.Results:
            print "Error code for %s/%d is 0x%x" %(
                str(ipaddress.ip_address(result.Prefix)),
                result.PrefixLen,
                result.ErrStatus.Status
            )
</pre><p>That's all for now! Remember some key takeaways:</p>
<ol type="1">
<li>The VRF must be registered before adding, updating, or removing routes from the RIB.</li>
<li>All API operations are CRUD based (Create, Read, Update, Delete), and the initial setup of all calls to the same object will be (about) the same. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 1 2016 01:48:57 for Cisco Service Layer API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
